/**
 * @file data.hpp
 * @brief This file provides the core voxel storage data structures used by @ref foxl.
 *
 * @details This file contains the @ref foxl::Voxel struct, the @ref foxl::VoxelStorage interface, and the following classes implementing @ref foxl::VoxelStorage:
 * - @ref foxl::DenseVoxelGrid
 * - @ref foxl::BasicSVO
 *
 * @author FrederickAmpsUp
 * @todo Finish documentation, the @ref foxl::BasicSVO class and add a `CompressedSVOBuffer` class.
 */

#pragma once

#include <cstdint>
#include <memory>
#include <glm/glm.hpp>

namespace foxl {

/**
 * @brief A single voxel.  
 * @details This struct stores a boolean `is_filled` and a 23-bit uint `prop_idx`.  
 * `is_filled` is true if the voxel "exists" in its space.  
 * `prop_idx` is an index into an array of properties. These may be visual, physical, or any other property.  
 *  
 * `is_filled` and `prop_idx` are compressed into a single 32-bit uint.
 */
struct Voxel {
private:
	uint32_t data;

public:
	/**
	 * @brief Creates a new voxel.
	 * @param is_filled The value of the voxel's `is_filled` property.
	 * @param prop_idx The value of the voxel's `prop_idx` property.
	 * @details It's not recommended to directly create a voxel, instead use a voxel generated by a @ref VoxelStorage implementation.
	 */
	Voxel(bool is_filled, uint32_t prop_idx);

	/**
	 * @brief Creates a new (empty) voxel.
	 * @details It's not recommended to directly create a voxel, instead use a voxel generated by a @ref VoxelStorage implementation
	 */
	Voxel();

	/**
	 * @brief Returns the voxel's `is_filled` property.
	 * @returns The voxel's `is_filled` property.
	 */
	bool is_filled() const;
	
	/**
	 * @brief Returns the voxel's `prop_idx` property.
	 * @returns The voxel's `prop_idx` property.
	 */
	uint32_t prop_idx() const;

	/**
	 * @brief Sets the voxel's `is_filled` property.
	 * @param is_filled The new value of the `is_filled` property.
	 */
	void is_filled(bool is_filled);
	
	/**
	 * @brief Sets the voxel's `prop_idx` property.
	 * @param prop_idx The new value of the `prop_idx` property.
	 */
	void prop_idx(uint32_t prop_idx);
};

/**
 * @brief A base class for all voxel storage constructs.
 * @details This class defines common methods for getting and setting voxels and interacting with the structure.
 */
class VoxelStorage {
public:
	/**
	 * @brief Get a constant reference to a @ref Voxel at a specific position.
	 * @param pos The position (3-d index) of the voxel to access.
	 * @returns A constant reference to the @ref Voxel at the specified position.
	 * @details To modify the voxel, use @ref operator[] or @ref set.
	 */
	virtual const Voxel& get(const glm::uvec3& pos) const = 0;

	/**
	 * @brief Sets the data of a @ref Voxel at a specific position.
	 * @param voxel The @ref Voxel to copy into the specified position.
	 * @param pos The position (3-d index) of the voxel to modify.
	 */
	virtual void set(const Voxel& voxel, const glm::uvec3& pos) = 0;

	/**
	 * @brief Get a mutable reference to a @ref Voxel at a specific position.
	 * @param pos The position (3-d index) of the voxel to access.
	 * @returns A mutable reference to the @ref Voxel at the specified position.
	 */
	virtual Voxel& operator[](const glm::uvec3& pos) = 0;

	/**
	 * @brief Get a constant reference to a @ref Voxel at a specific position.
	 * @param pos The position (3-d index) of the voxel to access.
	 * @returns A constant reference to the @ref Voxel at the specified position.
	 * @details This is equivalent to @ref get.
	 */
	virtual const Voxel& operator[](const glm::uvec3& pos) const = 0;

	virtual ~VoxelStorage() = 0;
};

/**
 * @brief This is required because C++ decides to destruct the pure virtual class that should never be constructed.
 *
 * @details God I wish I could write everything in Rust.
 */
inline VoxelStorage::~VoxelStorage() {}

/**
 * @brief The simplest and fastest form of voxel data storage.
 *
 * @details This structure stores voxels in a dense grid, or a 3-d array of voxels.  
 * It's very simple to implement and very fast to access, but uses a lot of memory and is slow for tasks like raycasting.
 */
class DenseVoxelGrid : public VoxelStorage {
public:
	/**
	 * @brief Creates an empty voxel grid with the specified dimensions.
	 * @param dims The dimensions (XYZ) of the voxel grid.
	 */
	DenseVoxelGrid(const glm::uvec3& dims);

	virtual const Voxel& get(const glm::uvec3& pos) const override;

	virtual void set(const Voxel& voxel, const glm::uvec3& pos) override;

	virtual Voxel& operator[](const glm::uvec3& pos) override;
	virtual const Voxel& operator[](const glm::uvec3& pos) const override;

	virtual ~DenseVoxelGrid() override = default;
private:
	std::unique_ptr<Voxel[]> data;
	glm::uvec3 dims;

	unsigned int index(const glm::uvec3& pos) const;
};

/**
 * @brief A common form of voxel storage based on a hierarchical structure.
 *
 * @details This structure consists of many nodes. Each node is either a single voxel, is completely empty, or has 8 child nodes.  
 * It's a bit complex to implement, and has logarithmic-time access, but uses less memory than a dense grid for mostly empty storage.  
 * It also allows for extremely fast raycasting by providing simple empty space skipping.
 */
class BasicSVO : public VoxelStorage {
public:
	/**
	 * @brief A single node in the SVO hierarchy.
	 * 
	 * @details This struct contains a set of flags, and zero or one of the following:  
	 * - A single @ref Voxel, or
	 * - A list of 8 child @ref Node s.
	 */
	struct Node {
		/**
		 * @brief Creates a new empty node.
		 */
		Node();

		/**
		 * @brief The "is voxel" flag, representing if the node is a leaf node in the tree.
		 */
		static const uint8_t IS_VOXEL = 0x01;
		/**
		 * @brief The "is empty" flag, representing if the node contains zero children.
		 */
		static const uint8_t IS_EMPTY = 0x02;
		
		/**
		 * @brief The bitset of flags.
		 */
		uint8_t flags;

		/**
		 * @brief Using a union allows us to store either a @ref Voxel or the child @ref Node s with a smaller memory footprint.
		 */
		union {
			/**
			 * @brief The potential @ref Voxel represented by the node.
			 */
			Voxel voxel;
			/**
			 * @brief The potential list of child @ref Node s under this @ref Node.
			 */
			std::unique_ptr<Node[8]> children;
		};

		/**
		 * @brief Returns wether this @ref Node is a @ref Voxel.
		 * @returns Wether this @ref Node is a @ref Voxel.
		 */
		bool is_voxel() const;
		/**
		 * @brief Returns wether this @ref Node is emtpy.
		 * @returns Wether this @ref Node is empty.
		 */
		bool is_empty() const;

		~Node();
	};

	/**
	 * Creates an empty SVO with at least the specified dimensions.
	 * @param dims The minimum dimension to use for the SVO. This may be rounded up to the nearest cube with side lengts which are a power of 2.
	 */
	BasicSVO(glm::uvec3 dims);

	virtual const Voxel& get(const glm::uvec3& pos) const override;

	virtual void set(const Voxel& voxel, const glm::uvec3& pos) override;

	virtual Voxel& operator[](const glm::uvec3& pos) override;
	virtual const Voxel& operator[](const glm::uvec3& pos) const override;

	~BasicSVO();
private:
	Node root;
	glm::uvec3 dims;
};
}
